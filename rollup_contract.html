<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rollup Contract - Aztec Connect</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/style.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');
                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }
                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item expanded affix "><li class="part-title">Other</li><li class="chapter-item expanded "><a href="primitives.html"><strong aria-hidden="true">2.</strong> Primitives</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="schnorr.html"><strong aria-hidden="true">2.1.</strong> Schnorr Signatures</a></li><li class="chapter-item expanded "><a href="uint.html"><strong aria-hidden="true">2.2.</strong> Unsigned integers</a></li></ol></li><li class="chapter-item expanded "><a href="notes_and_nullifiers.html"><strong aria-hidden="true">3.</strong> Notes & Nullifiers</a></li><li class="chapter-item expanded "><a href="defi_bridge_interface.html"><strong aria-hidden="true">4.</strong> Defi Bridge Interface</a></li><li class="chapter-item expanded affix "><li class="part-title">'App' Circuits</li><li class="chapter-item expanded "><a href="account_circuit.html"><strong aria-hidden="true">5.</strong> Account Circuit</a></li><li class="chapter-item expanded "><a href="join_split_circuit.html"><strong aria-hidden="true">6.</strong> Join-Split Circuit</a></li><li class="chapter-item expanded "><a href="claim_circuit.html"><strong aria-hidden="true">7.</strong> Claim Circuit</a></li><li class="chapter-item expanded affix "><li class="part-title">Rollup Circuits</li><li class="chapter-item expanded "><a href="rollup_circuit.html"><strong aria-hidden="true">8.</strong> Rollup Circuit</a></li><li class="chapter-item expanded "><a href="root_rollup_circuit.html"><strong aria-hidden="true">9.</strong> Root Rollup Circuit</a></li><li class="chapter-item expanded "><a href="root_verifier_circuit.html"><strong aria-hidden="true">10.</strong> Root Verifier Circuit</a></li><li class="chapter-item expanded affix "><li class="part-title">Contracts</li><li class="chapter-item expanded "><a href="rollup_contract.html" class="active"><strong aria-hidden="true">11.</strong> Rollup Contract</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Aztec Connect</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="rollup-contract"><a class="header" href="#rollup-contract">Rollup Contract</a></h1>
<p>Rollup contract is responsible for processing Aztec zkRollups, relaying them to a verifier contract for validation and performing all relevant token transfers and defi bridge interactions.</p>
<h2 id="high-level-overview-of-layer-2-architecture"><a class="header" href="#high-level-overview-of-layer-2-architecture">High-Level Overview of Layer 2 Architecture</a></h2>
<p>The specifics of the Layer 2 architecture are not explicitly in scope for the smart contract audit, as the rules/transaction semantics are defined via the logic in our ZK-SNARK cryptographic circuits, not the L1 smart contracts.</p>
<p>However, understanding the architecture may be useful to better understand the logic of the rollup processor smart contract, and the logic it executes when processing a rollup block.</p>
<h3 id="state-model"><a class="header" href="#state-model">State Model</a></h3>
<p>L2 state is recorded in 5 append-only databases, represented as Merkle trees. The Rollup contract records the roots of each tree via the rollupStateHash variable.</p>
<p>A call to the <em>processRollup(...)</em> method is, at its core, a request to update the roots of the above Merkle trees due to changes in the underlying databases from a block of L2 transactions.</p>
<p>The main databases/Merkle trees are:</p>
<ul>
<li><strong>dataTree</strong> contains UTXO notes that contain all created <em>value notes</em> and <em>account notes</em></li>
<li><strong>defiTree</strong> contains the results of previous L1 contract interactions instigated from the rollup contract</li>
<li><strong>rootTree</strong> contains all past (and the present) Merkle roots of the dataTree.
Used in L2 transactions to prove the existence of notes in the dataTree.</li>
</ul>
<p>The <em>dataTree</em> and <em>defiTree</em> have with it associated a shared nullifier set.
A nullifier set is an additional database which is also represented as a Merkle tree whose roots are included in <em>rollupStateHash</em>.
This nullifier set can be shared because there is no risk of collisions.</p>
<p>Nullifier sets record all items that have been deleted from their linked database.
The encryption algorithm used to encrypt nullifiers is different from the encryption used for their counterpart objects in their linked database.
This gives us the property of unlinkability - observers cannot link note creation to note destruction, which obscures the transaction graph.</p>
<p>The <em>rootTree</em> has no linked nullifier set as it is not possible to delete members of <em>rootTree</em>.</p>
<h2 id="l2-data-structures"><a class="header" href="#l2-data-structures">L2 data structures</a></h2>
<p>The following is a brief description of the data structures in the Aztec L2 architecture.
See <a href="./notes_and_nullifiers.html">notes_and_nullifiers</a> for a more complete descriptions.</p>
<p><strong>Value notes</strong> are stored in the <em>dataTree</em>.
They represent a discrete sum of ETH, ERC20 tokens or virtual assets held by a user.</p>
<p><strong>Account notes</strong> are stored in the <em>dataTree</em>.
They link a human-readable alias to both an account public key and to a spending public key.
A user can have multiple account notes with multiple spending keys, but all must share the same alias and account key.</p>
<blockquote>
<p>Note: Account keys are used to decrypt/view notes, spending keys are required to spend notes.
The security requirements for the former are weaker than the latter, as spending keys are required to move user funds.</p>
</blockquote>
<p><strong>DeFi notes</strong> are stored in the <em>defiTree</em>.
They represent a result of an L1 contract interaction instigated by the rollup processor contract.
This type of note records the number of input/output assets from the interaction (as well as their asset types) and information about whether the corresponding interaction succeeded/failed.</p>
<p><strong>Claim notes</strong> are stored in the <em>dataTree</em>.
This type of note represents a claim on the future proceeds of an L1 contract interaction.
Claim notes are created from value notes, and are converted back into value notes with the help of a defi note.</p>
<h2 id="l2-high-level-circuit-architecture"><a class="header" href="#l2-high-level-circuit-architecture">L2 high-level circuit architecture</a></h2>
<p>The Aztec network utilizes the following ZK-SNARK circuits to describe and validate L2 transactions:</p>
<h3 id="single-transaction-circuits"><a class="header" href="#single-transaction-circuits">Single transaction circuits</a></h3>
<p><strong>Join-Split circuit</strong>
Describes a single <em>deposit/withdraw/spend/defiDeposit</em> transaction.
Proof is created by the user on their local hardware.</p>
<p><strong>Account circuit</strong>
Describes a single <em>account</em> transaction.
Proof is created by the user on their local hardware.</p>
<p><strong>Claim circuit</strong>
Describes a single <em>defiClaim</em> transaction.
Proof is created by the rollup provider since no secret information is required to create a proof.
This is for convenience since in theory this proof could be created by a user locally.
Proof creation is deferred to the rollup provider for better user UX.</p>
<h3 id="rollup-circuits"><a class="header" href="#rollup-circuits">Rollup circuits</a></h3>
<p>There are 3 circuit types used in AztecConnect:</p>
<ol>
<li>
<p><strong>Inner rollup circuit</strong> verifies up to 28 single transaction proofs and performs required L2 state updates.</p>
</li>
<li>
<p><strong>Root rollup circuit</strong> is referred to as a rollup circuit in the smart contract code/comments.
This circuit verifies up to 28 inner rollup proofs.</p>
</li>
<li>
<p><strong>Root verifier circuit</strong> verifies a single root rollup proof.</p>
</li>
</ol>
<p>The inner rollup/root rollup design was introduced in order to enable better parallelism.</p>
<p>Knowledge of the existence of the <em>root verifier circuit</em> is likely beyond the scope of this audit.
It is used to simplify the computations required by the smart contract <a href="../../../../blockchain/contracts/verifier/StandardVerifier.sol">PLONK verifier</a>.
All other circuits/proofs are created using the “Turbo PLONK” ZK-SNARK proving system.</p>
<p>Regular PLONK proofs are slower to construct but faster to verify compared to Turbo PLONK proofs.
The <em>root verifier circuit</em> is made using regular PLONK, and it verifies the Turbo PLONK <em>root rollup circuit</em>.
This reduces the computations (and gas costs) required to verify the proof on-chain.</p>
<p>Aztec uses recursive ZK-SNARK constructions to ensure that only the final ZK-SNARK proof in the transaction stack needs to be verified on-chain. If the root verifier proof is correct, one can prove inductively that all other proofs in the transaction stack are correct.</p>
<h2 id="l2-transaction-types"><a class="header" href="#l2-transaction-types">L2 transaction types</a></h2>
<p>An Aztec rollup block contains up to 896 individual user transactions, which represent one of seven transaction types.
Each transaction type is defined via a <em>proofId</em> variable attached to the transaction.</p>
<table><thead><tr><th>proofId</th><th>transaction type</th><th>description</th></tr></thead><tbody>
<tr><td>0</td><td>padding</td><td>An empty transaction - present when there are not enough user transactions to fill the block</td></tr>
<tr><td>1</td><td>deposit</td><td>Converts public L1 ETH/ERC20 tokens into value notes</td></tr>
<tr><td>2</td><td>withdraw</td><td>Converts value notes into public ETH/ERC20 tokens on L1</td></tr>
<tr><td>3</td><td>spend</td><td>Private L2 transaction - converts value notes into different value notes</td></tr>
<tr><td>4</td><td>account</td><td>Creates a user account note</td></tr>
<tr><td>5</td><td>defiDeposit</td><td>Converts a value note into a claim note</td></tr>
<tr><td>6</td><td>defiClaim</td><td>Converts a claim note into a value note</td></tr>
</tbody></table>
<h3 id="anatomy-of-an-l2-transaction"><a class="header" href="#anatomy-of-an-l2-transaction">Anatomy of an L2 transaction</a></h3>
<p>Each user transaction in the rollup block will have 8 <code>uint256</code> variables associated with it, present in the transaction calldata when <code>processRollup(...)</code> is called.
While represented as a <code>uint256</code> in the smart contract, these variables are big integers taken modulo the BN254 elliptic curve group order.
This is verified in <a href="../../../../blockchain/contracts/verifier/StandardVerifier.sol">StandardVerifier.sol</a>.
Not all fields are used by all transaction types.</p>
<table><thead><tr><th>publicInput</th><th>name</th><th>description</th></tr></thead><tbody>
<tr><td>0</td><td>proofId</td><td>Defines the transaction type (checked in the rollup ZK-SNARK)</td></tr>
<tr><td>1</td><td>noteCommitment1</td><td>The 1st note created by the transaction (if applicable)</td></tr>
<tr><td>2</td><td>noteCommitment2</td><td>The 2nd note created by the transaction (if applicable)</td></tr>
<tr><td>3</td><td>nullifier1</td><td>The 1st nullifier for any notes destroyed by the transaction (if applicable)</td></tr>
<tr><td>4</td><td>nullifier2</td><td>The 2nd nullifier for any notes destroyed by the transaction (if applicable)</td></tr>
<tr><td>5</td><td>publicValue</td><td>Amount being deposited/withdrawn (if applicable)</td></tr>
<tr><td>6</td><td>publicOwner</td><td>Ethereum address of a user depositing/withdrawing funds (if applicable)</td></tr>
<tr><td>7</td><td>assetId</td><td>30-bit variable that represents the asset being deposited/withdrawn (if applicable)</td></tr>
</tbody></table>
<p>As not all fields are used by all transaction types, a custom encoding algorithm is used to reduce the calldata payload of these transactions. Transactions are decoded in Decoder.sol.</p>
<h3 id="data-included-in-a-rollup-transaction"><a class="header" href="#data-included-in-a-rollup-transaction">Data included in a rollup transaction</a></h3>
<p>When the <code>processRollup(...)</code> function is called, the input variable bytes calldata <code>encodedProofData</code> contains the core information required to validate and process an Aztec rollup block.</p>
<p>Due to significant gas inefficiencies in the Solidity ABI decoding logic, custom encoding is used and the overall data structure is wrapped in a bytes variable.</p>
<p>The proofData can be split into 3 key components:</p>
<ol>
<li><strong>Rollup header</strong> - a fixed-size block of data that records the key properties of the rollup block.</li>
<li><strong>Transaction data</strong> - a variable-size block that records the encoded user transaction data</li>
<li><strong>PLONK proof</strong> - fixed-size block of data that contains a PLONK ZK-SNARK validity proof that proves the L2 transaction logic has been correctly followed.</li>
</ol>
<p>Rollup Header Structure</p>
<table><thead><tr><th>byte range</th><th>num bytes</th><th>name</th><th>description</th></tr></thead><tbody>
<tr><td>0x00 - 0x20</td><td>32</td><td>rollupId</td><td>Unique rollup block identifier. Equivalent to block number</td></tr>
<tr><td>0x20 - 0x40</td><td>32</td><td>rollupSize</td><td>Max number of transactions in the block</td></tr>
<tr><td>0x40 - 0x60</td><td>32</td><td>dataStartIndex</td><td>Position of the next empty slot in the Aztec <em>dataTree</em></td></tr>
<tr><td>0x60 - 0x80</td><td>32</td><td>oldDataRoot</td><td>Root of the <em>dataTree</em> prior to rollup block’s state updates</td></tr>
<tr><td>0x80 - 0xa0</td><td>32</td><td>newDataRoot</td><td>Root of the <em>dataTree</em> after rollup block’s state updates</td></tr>
<tr><td>0xa0 - 0xc0</td><td>32</td><td>oldNullRoot</td><td>Root of the nullifier tree prior to rollup block’s state updates</td></tr>
<tr><td>0xc0 - 0xe0</td><td>32</td><td>newNullRoot</td><td>Root of the nullifier tree after rollup block’s state updates</td></tr>
<tr><td>0xe0 - 0x100</td><td>32</td><td>oldDataRootsRoot</td><td>Root of the tree of <em>dataTree</em> roots prior to rollup block’s state updates</td></tr>
<tr><td>0x100 - 0x120</td><td>32</td><td>newDataRootsRoot</td><td>Root of the tree of <em>dataTree</em> roots after rollup block’s state updates</td></tr>
<tr><td>0x120 - 0x140</td><td>32</td><td>oldDefiRoot</td><td>Root of the <em>defiTree</em> prior to rollup block’s state updates</td></tr>
<tr><td>0x140 - 0x160</td><td>32</td><td>newDefiRoot</td><td>Root of the <em>defiTree</em> after rollup block’s state updates</td></tr>
<tr><td>0x160 - 0x560</td><td>1024</td><td>bridgeCallDatas[NUMBER_OF_BRIDGE_CALLS]</td><td>Size-32 array of <code>bridgeCallDatas</code> for bridges being called in this block. If <code>bridgeCallData</code> == 0, no bridge is called.</td></tr>
<tr><td>0x560 - 0x960</td><td>1024</td><td>depositSums[NUMBER_OF_BRIDGE_CALLS]</td><td>Size-32 array of deposit values being sent for bridges being called in this block</td></tr>
<tr><td>0x960 - 0xb60</td><td>512</td><td>assetIds[NUMBER_OF_ASSETS]</td><td>Size-16 array of the assetIds for assets being deposited/withdrawn/used to pay fees in this block</td></tr>
<tr><td>0xb60 - 0xd60</td><td>512</td><td>txFees[NUMBER_OF_ASSETS]</td><td>Size-16 array of transaction fees paid to the rollup beneficiary, denominated in each assetId</td></tr>
<tr><td>0xd60 - 0x1160</td><td>1024</td><td>interactionNotes[NUMBER_OF_BRIDGE_CALLS]</td><td>Size-32 array of defi interaction result commitments that must be inserted into the <em>defiTree</em> at this rollup block</td></tr>
<tr><td>0x1160 - 0x1180</td><td>32</td><td>prevDefiInteractionHash</td><td>A SHA256 hash of the data used to create each interaction result commitment. Used to validate correctness of interactionNotes</td></tr>
<tr><td>0x1180 - 0x11a0</td><td>32</td><td>rollupBeneficiary</td><td>The address that the fees from this rollup block should be sent to. Prevents a rollup proof being taken from the transaction pool and having its fees redirected</td></tr>
<tr><td>0x11a0 - 0x11c0</td><td>32</td><td>numRollupTxs</td><td>Number of “inner rollup” proofs used to create the block proof. “inner rollup” circuits process 3-28 user txns, the outer rollup circuit processes 1-28 inner rollup proofs.</td></tr>
</tbody></table>
<p>N.B. our documentation will sometimes refer to a “note” as a “commitment” (they are effectively synonyms in our architecture).</p>
<h2 id="security-properties-of-aztec"><a class="header" href="#security-properties-of-aztec">Security properties of Aztec</a></h2>
<p>The tokens/ETH in every un-spent value note in the <em>dataTree</em> must be fully collateralised on-chain.
That is, the <em>RollupProcessor.sol</em> contract must own enough ERC20 tokens/ETH to cover the value represented in all of its un-spent notes.</p>
<p>Consequently, whenever a user creates a deposit transaction, they must have previously transferred/approved an equivalent amount of ETH/tokens to <em>RollupProcessor.sol</em>.</p>
<p>It should also not be possible for an attacker to create value notes that are linked to ETH/tokens deposited by a different user without their express permission.</p>
<p>More generally it is essential that front-running attacks are not possible.
Front-running attacks are attacks where an attacker takes a transaction out of the transaction pool and manipulates it to re-route value to/from an account not intended by the original transaction sender.</p>
<p>Value can also be deposited to the system via defi interactions.
When claim notes are converted into value notes, an equivalent amount of ETH/tokens must have been deposited into the bridge by a defi interaction (described in the next section).</p>
<p>When value is extracted from <em>RollupProcessor.sol</em>, an equivalent amount of value recorded in value notes must have been destroyed.</p>
<p>Assuming the cryptography is correct, this means that in <code>processRollup(...)</code>’s call-data, there must be a withdraw transaction whose value field matches the amount being withdrawn.</p>
<p>Alternatively, value can be extracted if the rollup header contains a non-zero value inside the <code>depositSums</code> array (this implies that value notes have been converted into claim notes and we are instructing the rollup to send tokens to a specified bridge contract).</p>
<h2 id="anatomy-of-an-aztec-connect-defi-transaction"><a class="header" href="#anatomy-of-an-aztec-connect-defi-transaction">Anatomy of an Aztec Connect defi transaction</a></h2>
<p>An outbound defi interaction is described by an instance of a <code>FullBridgeCallData</code> and a <code>depositSum</code> (present in the rollup header in the <code>bridgeCallDatas</code> and <code>depositSums</code> arrays).</p>
<p>An instance of the struct uniquely defines the expected inputs/outputs of a defi interaction.
Before being unpacked to the aforementioned struct the values (other than <code>bridgeGasLimit</code> and <code>bridgeAddress</code>) are being encoded in a <code>unit256</code> bit-string containing multiple fields.
When unpacked, its data is used to create the <code>FullBridgeCallData</code> struct:</p>
<pre><code>struct FullBridgeCallData {
  uint256 bridgeAddressId;
  address bridgeAddress;
  uint256 inputAssetIdA;
  uint256 inputAssetIdB;
  uint256 outputAssetIdA;
  uint256 outputAssetIdB;
  uint256 auxData;
  bool firstInputVirtual;
  bool secondInputVirtual;
  bool firstOutputVirtual;
  bool secondOutputVirtual;
  bool secondInputInUse;
  bool secondOutputInUse;
  uint256 bridgeGasLimit;
}
</code></pre>
<p>For specific encoding/decoding logic see comments in <em>RollupProcessor.sol</em>.</p>
<p>A bridge contract is an L1 smart contract that translates the interface of a generic smart contract into the Aztec Connect interface.</p>
<p>Interactions are modelled as synchronous or asynchronous token transfers.
Input assets are sent to a bridge contract and up to two different output assets are returned.
The exchange rate between the input/output assets is assumed to be unknown until the transaction is mined.</p>
<p>Input/output assets can be either “real” or “virtual”.
A “real” token has an underlying ERC20 smart contract (or is ETH).
A “virtual” token exists entirely inside the Aztec network, with no L1 counterpart.
It is used to efficiently track synthetic values (such as the amount of outstanding value in a loan, or votes in a DAO).</p>
<p><em>RollupProcessor</em> enforces that <code>_totalInputValue</code> is non-zero.
If both input assets are used, <code>_totalInputValue</code> amount of both input assets is transferred to the bridge before a bridge is called.</p>
<p><strong>BOTH</strong> output assets could be virtual but since their <code>assetId</code> is currently assigned as an interaction nonce of a given interaction it would simply mean that more of the same virtual asset is minted.</p>
<h2 id="defi-transaction-flow"><a class="header" href="#defi-transaction-flow">DeFi Transaction Flow</a></h2>
<p>If a rollup block contains DeFi interactions a <code>processBridgeCalls(...)</code> function is called.
In the function, the following occurs:</p>
<ol>
<li>All outbound defi interactions in the rollup block are iterated over. For each interaction:</li>
<li>Input tokens are transferred to the specified bridge contract</li>
<li>The bridge contract has to return 3 parameters: <code>uint256 outputValueA</code>, <code>uint256 outputValueB</code>, <code>bool isAsync</code></li>
<li>When some of the output assets is an <code>ERC20</code> token and the corresponding output value is non-zero, the contract attempts to recover the tokens via calling <code>transferFrom(...)</code>.
If the asset is ETH, bridge transfers it in to the <em>RollupProcessor</em> and <em>RollupProcessor</em> validates it has received a correctly-sized ETH payment.
This payment is linked to the defi interaction through <code>_interactionNonce</code>.</li>
<li>A <code>defiInteractionResult</code> object is constructed based on the results of the above.</li>
</ol>
<p>The logic for processing a single defi transaction is wrapped in a <em>DefiBridgeProxy</em> smart contract.
This smart contract is called from the <em>RollupProcessor</em> via <code>delegateCall(...)</code>.
The purpose of this is to enable the call stack to be partially unwound if any step of the defi interaction fails.</p>
<blockquote>
<p>E.g. consider a defi interaction where 10 ETH is sent to the and the expected return asset is DAI.
If the defi bridge contract reverts, we want to recover the 10 ETH that was sent to the contract, without causing the entire rollup block to revert (which would enable griefing attacks).
Similarly imagine we send 10 ETH to a bridge, which claims its outputValueA is 100 DAI.
If a call to <code>DAI.transferFrom(...)</code> fails, we want to unwind the call stack such that 10 ETH never left <em>RollupProcessor</em>.</p>
</blockquote>
<p>If the <em>DefiBridgeProxy</em> call fails, we record this in the <code>defiInteractionResult</code>.
This allows for a future <em>defiClaim</em> transaction to convert any linked claim notes back into value notes.
This effectively returns the value (less the fee) to the user.</p>
<p>The expected interface for defi bridges is defined in <a href="../../../../blockchain/contracts/interfaces/IDefiBridge.sol">IDefiBridge</a>.</p>
<h2 id="encoding-and-decoding--of-proof-data"><a class="header" href="#encoding-and-decoding--of-proof-data">Encoding and Decoding  of Proof Data</a></h2>
<p>For info about proof data encoding check out documentation of <a href="../../../../blockchain/contracts/Decoder.sol">Decoder</a> contract.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="root_verifier_circuit.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="root_verifier_circuit.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/sidebar.js"></script>
    </body>
</html>